# Quadratic probing is an open addressing scheme in computer programming for resolving hash collisions in hash tables. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open or empty slot is found.

# An example of a sequence using quadratic probing is:
# h, h + 1, h + 4, h + 9 ... h + i²

# Quadratic function
# Let h(k) = k mod m be a hash function that maps an element k to an integer in [0, m−1], where m is the size of the table. Let the i-th probe position for a value k be given by the function
# h(k, i) = (h(k) + c₁i + c₂i²) mod m
# where c₁ and c₂ are positive integers. The value of i = 0, 1, ..., m−1. So we start from i = 0, and increase this until we get one free slot in hash table.

# For a given class Hashing, create two methods:

# store_data(data): That accepts a positive integer data and generate an index value (0 to m-1) using given quadratic function and stores data in hashtable list on corresponding index generated by quadratic function. hashtable can contain only m data items. So, if all are already filled, then print Hash table is full.

# display_hashtable(): That returns hashtable


class Hashing:
  def __init__(self,c1,c2,m):
    self.hashtable = []
    for i in range(m):
        self.hashtable.append(None)     
    self.c1 = c1
    self.c2 = c2
    self.m = m
  def store_data(self, data):
        for i in range(self.m):
            idx = (data % self.m + self.c1 * i + self.c2 * i * i) % self.m
            if self.hashtable[idx] is None:
                self.hashtable[idx] = data
                return
        print("Hash table is full")

  def display_hashtable(self):
        return self.hashtable


c1 = int(input())
c2 = int(input())
m = int(input())
data=eval(input())
A = Hashing(c1,c2,m)
for i in data:
	A.store_data(i)
print(A.display_hashtable())